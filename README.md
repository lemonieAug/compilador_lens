# Lens ‚Äî Lightweight Efficient Neutral Syntax

> Uma linguagem de programa√ß√£o leve, eficiente, neutra e de sintaxe simples.

---

## ‚ú® Sobre a Lens

**Lens** √© uma linguagem de programa√ß√£o fict√≠cia, criada com o objetivo de ser:

* **Lightweight** ‚Äî Estrutura minimalista e r√°pida de entender
* **Efficient** ‚Äî Opera√ß√µes b√°sicas feitas de forma direta e objetiva
* **Neutral** ‚Äî Sem impor estilos de programa√ß√£o complexos ou paradigmas espec√≠ficos
* **Syntax** ‚Äî Focada em uma sintaxe intuitiva e limpa

A Lens possui **tipagem est√°tica obrigat√≥ria**, e n√£o possui fun√ß√µes ou objetos nesta vers√£o. √â ideal para fins **did√°ticos**, como ensino de l√≥gica, cria√ß√£o de compiladores e exploradores de gram√°ticas com ANTLR.

---

## ‚öôÔ∏è Analisador Sem√¢ntico

Este reposit√≥rio implementa um **Analisador Sem√¢ntico** completo para programas Lens, com base no parser gerado pelo ANTLR4.

Ele realiza as seguintes valida√ß√µes:

| Verifica√ß√£o sem√¢ntica                          | Suporte |
| ---------------------------------------------- | ------- |
| Uso de vari√°veis sem declara√ß√£o                | ‚úîÔ∏è      |
| Uso de vari√°veis antes de atribui√ß√£o           | ‚úîÔ∏è      |
| Declara√ß√£o duplicada de vari√°veis              | ‚úîÔ∏è      |
| Tipos incompat√≠veis em atribui√ß√µes             | ‚úîÔ∏è      |
| Opera√ß√µes aritm√©ticas entre tipos inv√°lidos    | ‚úîÔ∏è      |
| Opera√ß√µes l√≥gicas com n√£o-booleanos            | ‚úîÔ∏è      |
| Divis√£o por zero                               | ‚úîÔ∏è      |
| Escopo correto em `if`, `else`, `for`, `while` | ‚úîÔ∏è      |

---

## üì¶ Estrutura de Arquivos

```
project/
‚îú‚îÄ‚îÄ main.py                  # Executa o analisador
‚îú‚îÄ‚îÄ SemanticAnalyzer.py      # L√≥gica do analisador sem√¢ntico
‚îú‚îÄ‚îÄ ErrorHandler.py          # Tratamento de erros l√©xicos/sint√°ticos
‚îú‚îÄ‚îÄ lens.g4                  # Gram√°tica ANTLR da linguagem Lens
‚îú‚îÄ‚îÄ generated/               # Arquivos gerados pelo ANTLR
‚îÇ   ‚îú‚îÄ‚îÄ lensLexer.py
‚îÇ   ‚îú‚îÄ‚îÄ lensParser.py
‚îÇ   ‚îú‚îÄ‚îÄ lensVisitor.py
‚îú‚îÄ‚îÄ script.lens              # C√≥digo de teste
‚îú‚îÄ‚îÄ analisador.log           # Log da an√°lise sem√¢ntica
‚îî‚îÄ‚îÄ ast.png                  # Visualiza√ß√£o da AST (opcional)
```

---

## üìÖ Entrada e üìÑ Sa√≠da na Lens

### üìÑ print

```lens
print:: "Nome:", nome, idade
```

### üìÖ input

```lens
input(nome)
```

---

## üß¨ Vari√°veis na Lens

### Declara√ß√£o

```lens
let idade: int
let nome: String = "Jo√£o"
```

### Atribui√ß√£o e Opera√ß√µes

```lens
idade = 20
idade = idade + 5
```

---

## üîÅ La√ßos

### `for`

```lens
for i in 0..5 {
    print:: i
}
```

### `while`

```lens
while i < 10 {
    print:: i
}
```

---

## üîÄ Condicionais

```lens
if ativo && idade >= 18 {
    print:: "Maior de idade"
} elseif idade == 17 {
    print:: "Quase l√°"
} else {
    print:: "Menor de idade"
}
```

---

## ‚úÖ Exemplo de An√°lise sem√¢ntica com erro

```lens
@start
    let nome: String
    print:: nome, idade
@end
```

Sa√≠da esperada:

```bash
[Erro Sem√¢ntico] Linha 3: Vari√°vel 'idade' usada sem declara√ß√£o.
```

---

## üõ†Ô∏è Como usar

1. Gere os arquivos do ANTLR:

```bash
antlr4 -Dlanguage=Python3 -visitor lens.g4 -o generated
```

2. Execute o analisador:

```bash
python main.py
```

3. Veja o log gerado:

* Terminal colorido com `colorama`
* Log salvo em `analisador.log`
* AST gerada com Graphviz (opcional)

---

## üìå Requisitos

* Python 3.10+
* `colorama` (para mensagens coloridas)

```bash
pip install colorama
```

* ANTLR 4.13+
* (Opcional) Graphviz para visualiza√ß√£o da AST

---

# Gerador de C√≥digo Intermedi√°rio (TACGenerator - Three-Address Code)


Este documento apresenta uma explica√ß√£o clara e objetiva sobre o funcionamento do gerador de TAC para a linguagem Lens, utilizando como base o c√≥digo da classe `TACGenerator`.

---

## 1. Objetivo Geral

O gerador de TAC tem como finalidade traduzir o c√≥digo-fonte da linguagem Lens para um c√≥digo intermedi√°rio em formato de Tr√™s Endere√ßos (Three-Address Code), facilitando etapas posteriores como a gera√ß√£o de c√≥digo de m√°quina.

---

## 2. Componentes Fundamentais

### 2.1. Tempor√°rios e Labels

```python
def new_temp(self):
    self.temp_counter += 1
    return f"_t{self.temp_counter}"

def new_label(self):
    self.label_counter += 1
    return f"L{self.label_counter}"
```

Essas fun√ß√µes s√£o usadas para criar nomes √∫nicos para vari√°veis tempor√°rias (\_t1, \_t2, ...) e labels (L1, L2, ...) que s√£o essenciais para controle de fluxo.

### 2.2. Emiss√£o de Instru√ß√µes

```python
def emit(self, op, arg1=None, arg2=None, result=None):
    instruction = {'op': op, 'arg1': arg1, 'arg2': arg2, 'result': result}
    self.instructions.append(instruction)
    return instruction
```

Essa fun√ß√£o adiciona uma instru√ß√£o TAC √† lista principal. Cada instru√ß√£o pode representar uma atribui√ß√£o, opera√ß√£o aritm√©tica, compara√ß√£o, leitura, impress√£o ou salto condicional.

### 2.3. Formata√ß√£o

```python
def format_instruction(self, instr):
    # Retorna a instru√ß√£o em forma leg√≠vel (ex: _t1 = a + b)
```

Serve para mostrar as instru√ß√µes TAC em um formato compreens√≠vel para humanos, por exemplo:

```
3: _t1 = idade + 5
```

---

## 3. Gera√ß√£o de C√≥digo por Elemento da Linguagem

### 3.1. Declara√ß√£o

```python
def visitDeclaracao(self, ctx):
    # Se houver express√£o, visita e gera ASSIGN
```

Gera c√≥digo para declara√ß√£o de vari√°vel, incluindo inicializa√ß√£o.

### 3.2. Atribui√ß√£o

```python
def visitAtribuicao(self, ctx):
    # Trata atribui√ß√µes simples e compostas como idade += 5
```

Identifica se √© uma atribui√ß√£o simples (`x = y`) ou composta (`x += y`) e gera o TAC correspondente.

### 3.3. Impress√£o

```python
def visitImpressao(self, ctx):
    # print :: valor
```

Gera uma ou mais instru√ß√µes `PRINT` para express√µes.

### 3.4. Entrada de Dados

```python
def visitEntrada(self, ctx):
    self.emit('read', None, None, var_name)
```

Cria uma instru√ß√£o `read` para entrada do usu√°rio.

### 3.5. Express√µes Aritm√©ticas e L√≥gicas

```python
def visitExpressao_arit(self, ctx):
    # _t1 = a + b
```

```python
def visitExpressao_logica(self, ctx):
    # _t3 = _t1 && _t2
```

Essas fun√ß√µes geram c√≥digo TAC para opera√ß√µes matem√°ticas e l√≥gicas.

---

## 4. Controle de Fluxo

### 4.1. Condicionais

```python
def visitCondicional(self, ctx):
    # if, elseif, else com IF_FALSE e GOTO
```

Para if/elseif/else, labels s√£o criados e usados para direcionar o fluxo com saltos condicionais.

### 4.2. La√ßos (While/For)

```python
def visitLacowhile(self, ctx):
    # while (cond) {...}
```

```python
def visitLacofor(self, ctx):
    # for i in a..b {...}
```

Usam `LABEL`, `IF_FALSE` e `GOTO` para simular os ciclos de repeti√ß√£o.

---

## 5. Exemplo de Sa√≠da TAC

Para o seguinte trecho da linguagem Lens:

```lens
let idade: int = 25
idade += 5
print :: idade
```

O TAC gerado seria:

```
1: _t1 = 25
2: idade = _t1
3: _t2 = idade + 5
4: idade = _t2
5: print idade
```

---

## 6. Conclus√£o

O TAC √© uma representa√ß√£o intermedi√°ria fundamental para compiladores. Esse gerador √© respons√°vel por transformar a estrutura da linguagem Lens em uma forma que facilita a an√°lise posterior pelo backend do compilador (LLVM IR, por exemplo).

Cada m√©todo "visit" corresponde a um n√≥ da √°rvore sint√°tica gerada pelo ANTLR. Isso garante modularidade e clareza na transforma√ß√£o do c√≥digo-fonte.

Esse processo tamb√©m ajuda o aluno a entender os conceitos de parsing, simboliza√ß√£o, e otimiza√ß√£o de c√≥digo.


---

## 2. Gerador de LLVM IR (LLVMIRGenerator)

# Vis√£o Geral Simplificada da Gera√ß√£o de C√≥digo LLVM IR

Este documento apresenta de forma clara e direta como o compilador da linguagem Lens gera c√≥digo intermedi√°rio em LLVM IR (Intermediate Representation), uma etapa fundamental no processo de compila√ß√£o.

---

## Objetivo

Transformar o c√≥digo da linguagem Lens em LLVM IR, que pode ser posteriormente compilado para um execut√°vel utilizando o compilador `clang`.

---

## Estrutura Geral

A gera√ß√£o √© feita pela classe `LLVMIRGenerator`. A fun√ß√£o principal aqui √© construir o arquivo `.ll` com base nas instru√ß√µes TAC previamente geradas.

---

## Cabe√ßalho do Arquivo LLVM IR

Logo no in√≠cio do arquivo LLVM, √© adicionado um cabe√ßalho com informa√ß√µes b√°sicas de compila√ß√£o:

```python
self.llvm_code.extend([
    "; C√≥digo LLVM IR gerado para a linguagem Lens",
    "; Gerado automaticamente pelo compilador",
    "",
    "target datalayout = \"e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"",
    "target triple = \"x86_64-pc-linux-gnu\"",
    ""
])
```

### Componentes:

* **Coment√°rios**: Informa√ß√µes sobre a origem do c√≥digo.
* **target datalayout**: Define o layout de dados na mem√≥ria.
* **target triple**: Define o sistema alvo da compila√ß√£o (`x86_64-pc-linux-gnu`, ou seja, Linux 64 bits).

---

## Fun√ß√£o `_generate_header`

```python
def _generate_header(self):
    """Gera o cabe√ßalho do arquivo LLVM."""
    self.llvm_code.extend([...])
```

Esta fun√ß√£o garante que o LLVM compreenda o ambiente alvo antes de iniciar a leitura das instru√ß√µes da fun√ß√£o `main`.

---

## Etapas de Gera√ß√£o

Ap√≥s gerar as instru√ß√µes TAC, o LLVMIRGenerator traduz essas instru√ß√µes para LLVM IR.

### Exemplo de Tradu√ß√£o TAC ‚Üí LLVM:

```python
if op == '+':
    llvm.append(f"%{res} = add i32 %{arg1}, %{arg2}")
elif op == 'ASSIGN':
    llvm.append(f"%{res} = add i32 0, %{arg1}")
```

* **Opera√ß√£o aritm√©tica**: `t1 = a + b` vira `%t1 = add i32 %a, %b`
* **Atribui√ß√£o simples**: `t2 = a` vira `%t2 = add i32 0, %a`

---

## Impress√£o de Strings

Strings s√£o armazenadas como vari√°veis globais constantes:

```llvm
@.str_1 = private unnamed_addr constant [13 x i8] c"Resultado: %d\0A\00"
```

E s√£o usadas com chamadas √† fun√ß√£o `printf` no corpo da fun√ß√£o `main`.

---

## Estrutura da Fun√ß√£o `main`

```llvm
define i32 @main() {
entry:
    ; instru√ß√µes LLVM IR aqui
    ret i32 0
}
```

Todas as instru√ß√µes TAC s√£o convertidas para LLVM e inseridas dentro da fun√ß√£o `main`.

---

## Como compilar com `clang`

Ap√≥s gerar o arquivo `output.ll`, o c√≥digo pode ser transformado em um execut√°vel:

```bash
clang output.ll -o output
```

---

## Considera√ß√µes

* O `target triple` √© fixo (n√£o detectado automaticamente).
* O c√≥digo gerado √© compat√≠vel com sistemas Linux de 64 bits.
* As instru√ß√µes s√£o otimizadas para facilitar a leitura e posterior compila√ß√£o.

---

## Conclus√£o

O gerador LLVM IR traduz o TAC para um formato compreendido por compiladores modernos como o `clang`. Isso permite compilar programas da linguagem Lens diretamente em c√≥digo de m√°quina, integrando perfeitamente o pipeline do compilador.


## 3. Execu√ß√£o do Programa

### 3.1 Gera√ß√£o do Execut√°vel

```bash
clang output.ll -o output
```

### 3.2 Inspe√ß√£o Opcional

```bash
llc output.ll -o output.s   # Assembly
clang -c output.ll -o output.o   # Objeto
```

---

## 4. Resumo do Pipeline

1. Parser (ANTLR) gera a AST.
2. `TACGenerator` converte AST em TAC:

   ```tac
   _t1 = 10 + 5
   print _t1
   ```
3. `LLVMIRGenerator` traduz TAC para LLVM IR:

   ```llvm
   %_t1 = add i32 10, 5
   call i32 (i8*, ...) @printf(i8* getelementptr ..., i32 %_t1)
   ```
4. Clang compila para bin√°rio:

   ```bash
   clang output.ll -o output
   ```

---

## 5. Depend√™ncias Necess√°rias

* **LLVM** (llvm-config, llc, clang)
* **Clang** (para compilar IR)
* **Opcional:** MinGW no Windows para gerar `.exe`

---

Este documento pode ser utilizado como base para apresenta√ß√µes, documenta√ß√£o do compilador ou manuais de uso.

---

## üí° Contribui√ß√µes e Licen√ßa

Este projeto tem fins educacionais. Sinta-se livre para explorar, adaptar e estender para estudos de compiladores.

---

> üöÄ Lens √© mais do que uma linguagem: √© uma porta de entrada para o estudo de como linguagens s√£o constru√≠das!
